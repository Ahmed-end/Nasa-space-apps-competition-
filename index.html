<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meteorite Defense Simulation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      color: white;
      font-family: Arial, sans-serif;
    }
    #container {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="container"></div>

<script>
let scene, camera, renderer, meteorite, earth, clouds, stars;
let meteoritePath = [];
let animationId;
let simulationActive = true;
let interventionApplied = false;
let meteoritePosition = { x: -200, y: 0, z: 0 };
let meteoriteVelocity = { x: 2, y: 0, z: 0 };
let earthPosition = { x: 100, y: 0, z: 0 };
let deviation = 0;
let timeStep = 0.1;
let totalTime = 0;
window.interventionIntervals = [];

function init() {
  // Scene setup
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('container').appendChild(renderer.domElement);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
  scene.add(ambientLight);

  const sunLight = new THREE.DirectionalLight(0xffffff, 1);
  sunLight.position.set(-300, 100, 100);
  scene.add(sunLight);

  // Background stars
  createStars();

  // Earth
  createEarth();

  // Meteorite
  createMeteorite();

  // Camera
  camera.position.set(0, 50, 150);
  camera.lookAt(0, 0, 0);

  // Start animation
  animate();
}

function createStars() {
  const starGeometry = new THREE.BufferGeometry();
  const starCount = 5000;
  const positions = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount * 3; i++) {
    positions[i] = (Math.random() - 0.5) * 2000;
  }
  starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
  stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);
}

function createEarth() {
  const loader = new THREE.TextureLoader();

  const earthTexture = loader.load("https://threejsfundamentals.org/threejs/resources/images/earth-day.jpg");
  const bumpMap = loader.load("https://threejsfundamentals.org/threejs/resources/images/earth-bump.jpg");
  const specularMap = loader.load("https://threejsfundamentals.org/threejs/resources/images/earth-specular.gif");
  const cloudTexture = loader.load("https://threejsfundamentals.org/threejs/resources/images/earth-clouds.png");

  const earthGeometry = new THREE.SphereGeometry(8, 64, 64);
  const earthMaterial = new THREE.MeshPhongMaterial({
    map: earthTexture,
    bumpMap: bumpMap,
    bumpScale: 0.3,
    specularMap: specularMap,
    specular: new THREE.Color('grey'),
    shininess: 10
  });
  earth = new THREE.Mesh(earthGeometry, earthMaterial);
  earth.position.set(earthPosition.x, earthPosition.y, earthPosition.z);
  scene.add(earth);

  // Clouds
  const cloudGeometry = new THREE.SphereGeometry(8.2, 64, 64);
  const cloudMaterial = new THREE.MeshPhongMaterial({
    map: cloudTexture,
    transparent: true,
    opacity: 0.4,
    depthWrite: false
  });
  clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
  clouds.position.copy(earth.position);
  scene.add(clouds);

  // Atmosphere glow
  const glowGeometry = new THREE.SphereGeometry(9, 64, 64);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: 0x00aaff,
    transparent: true,
    opacity: 0.2
  });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  glow.position.copy(earth.position);
  scene.add(glow);
}

function createMeteorite() {
  const loader = new THREE.TextureLoader();
  const rockTexture = loader.load("https://threejsfundamentals.org/threejs/resources/images/rock.jpg");

  const meteoriteGeometry = new THREE.SphereGeometry(2, 32, 32);
  const meteoriteMaterial = new THREE.MeshPhongMaterial({
    map: rockTexture,
    bumpMap: rockTexture,
    bumpScale: 0.5,
    shininess: 5
  });
  meteorite = new THREE.Mesh(meteoriteGeometry, meteoriteMaterial);
  meteorite.position.set(meteoritePosition.x, meteoritePosition.y, meteoritePosition.z);
  scene.add(meteorite);

  // Glow (outer fiery aura)
  const glowGeometry = new THREE.SphereGeometry(2.6, 32, 32);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: 0xff6600,
    transparent: true,
    opacity: 0.5
  });
  meteorite.glow = new THREE.Mesh(glowGeometry, glowMaterial);
  meteorite.add(meteorite.glow);

  // Trail
  const trailGeometry = new THREE.BufferGeometry();
  const trailMaterial = new THREE.LineBasicMaterial({
    color: 0xffaa00,
    transparent: true,
    opacity: 0.9
  });
  meteorite.trail = new THREE.Line(trailGeometry, trailMaterial);
  scene.add(meteorite.trail);
}

function animate() {
  if (!simulationActive) return;
  animationId = requestAnimationFrame(animate);

  // Meteorite movement
  meteoritePosition.x += meteoriteVelocity.x * timeStep;
  meteoritePosition.y += meteoriteVelocity.y * timeStep;
  meteoritePosition.z += meteoriteVelocity.z * timeStep;
  if (meteorite) meteorite.position.set(meteoritePosition.x, meteoritePosition.y, meteoritePosition.z);

  // Update fiery glow (brighter when closer to Earth)
  if (meteorite) {
    const distance = meteorite.position.distanceTo(earth.position);
    const glowStrength = Math.max(0.1, 1 - distance / 250); 
    meteorite.glow.material.opacity = glowStrength;
    meteorite.glow.scale.setScalar(1 + glowStrength * 2);
  }

  // Trail
  meteoritePath.push({ ...meteoritePosition });
  if (meteoritePath.length > 80) meteoritePath.shift();
  updateTrail();

  // Rotate Earth & clouds
  earth.rotation.y += 0.003;
  clouds.rotation.y += 0.004;
  stars.rotation.y += 0.0003;

  renderer.render(scene, camera);
}

function updateTrail() {
  if (!meteorite) return;
  const positions = [];
  const colors = [];
  const color = new THREE.Color();

  meteoritePath.forEach((p, i) => {
    positions.push(p.x, p.y, p.z);
    const t = i / meteoritePath.length;
    color.setHSL(0.1 + 0.1 * t, 1.0, 0.5 + 0.3 * (1 - t));
    colors.push(color.r, color.g, color.b);
  });

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  const trailMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.9 });

  meteorite.trail.geometry = geometry;
  meteorite.trail.material = trailMaterial;
}

function createExplosion(position) {
  const particles = new THREE.Group();
  const particleCount = 200;
  const geometry = new THREE.SphereGeometry(0.1, 8, 8);
  const material = new THREE.MeshBasicMaterial({ color: 0xff5500 });

  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(geometry, material.clone());
    particle.position.copy(position);
    particle.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 4,
      (Math.random() - 0.5) * 4,
      (Math.random() - 0.5) * 4
    );
    particles.add(particle);
  }

  scene.add(particles);

  let life = 0;
  const interval = setInterval(() => {
    life += 1;
    particles.children.forEach(p => {
      p.position.add(p.velocity);
      p.material.opacity = Math.max(0, 1 - life / 60);
    });
    if (life > 60) {
      scene.remove(particles);
      clearInterval(interval);
    }
  }, 30);
}

function createImpactEffect(position) {
  // Flash on Earth
  const flashGeometry = new THREE.SphereGeometry(8.2, 64, 64);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: 0xffff66,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  flash.position.copy(earth.position);
  scene.add(flash);

  let flashLife = 0;
  const flashInterval = setInterval(() => {
    flash.scale.setScalar(1 + flashLife * 0.05);
    flash.material.opacity = Math.max(0, 0.8 - flashLife * 0.05);
    flashLife++;
    if (flashLife > 20) {
      scene.remove(flash);
      clearInterval(flashInterval);
    }
  }, 50);

  // Shockwave ring
  const ringGeometry = new THREE.RingGeometry(0.1, 0.5, 64);
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0xff3300,
    transparent: true,
    opacity: 0.8,
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending
  });
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.position.copy(earth.position);
  ring.lookAt(camera.position);
  scene.add(ring);

  let shockLife = 0;
  const shockInterval = setInterval(() => {
    const scale = 1 + shockLife * 0.2;
    ring.scale.set(scale, scale, scale);
    ring.material.opacity = Math.max(0, 0.8 - shockLife * 0.05);
    shockLife++;
    if (shockLife > 25) {
      scene.remove(ring);
      clearInterval(shockInterval);
    }
  }, 50);
}

function destroyMeteorite(success = true) {
  if (!meteorite) return;
  createExplosion(meteorite.position.clone());
  if (!success) {
    createImpactEffect(earth.position.clone());
  }
  scene.remove(meteorite);
  scene.remove(meteorite.trail);
  meteorite = null;

  if (success) {
    console.log("âœ… Meteorite burned up before impact!");
  } else {
    console.log("ðŸ’¥ Meteorite impacted Earth with a shockwave!");
  }
}

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>
